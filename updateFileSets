#!/bin/bash

# this script updates file sets for all packages in the list below
# it scans all Venus OS versions in the stockFiles directory
#
# This is a unix bash script and should be run on a host computer, not a GX device
# Windows will not run this script natively.
# However Windows 10 apparently supports bash:
# https://www.howtogeek.com/249966/how-to-install-and-use-the-linux-bash-shell-on-windows-10/
#
# packages to be evaulated may be specified on the command line
# use 'all' to process all packages in the allPackages list below
#
# file sets for a version NOT contained in StockFiles will be flagged with UNUSED_FILE_SET
# this can occur if you remove versions from StockFiles.
# For example, you may wish to remove beta versions after a beta test cycle.

# stockFiles contains "master" file sets for all Venus files
# excerpts from Venus OS file systems must be stored on the host
# within a directory with name of the exact Venus OS version
# and within the stockFiles directory defined below.
#
# 1) missing file set directories are created
# 2) if any files in fileList don't exist (eg, a new file was added to file list),
#   the original file in /opt and /etc is copied to the version directory
# 3) if the original file does not exist, the file is so marked with .NO_ORIG
# 4) version-dependent files without an original can use an "alternate original"
#   specified in FileSets. This permits version checks for these files too
# 5) file sets that contain no files are removed, minimizing the number of file sets
#   to check for a matching original
#
# when a stock file set does not exist, this script will check files from existing file sets
#	to create other versions
#
# existing file sets not in the releasedVersionList should be empty after the script runs
#	and will be deleted automatically
#
# file sets will include all files listed in fileList.
# if the stock file matches a previous version, a symbolic link for the replacement is created
# rather than duplicating the file
# this allows the setup script to always have a replacement for known versions
# without searching other file sets for a matching original file
# there have been cases where installation fails because the search for a matching original could not be found.
# this also makes maintanence easier since matching replacement can be identified
#
# original files in the file set are not normally used when installing the package
# however, they are retained so that the setup script can attempt to create a file set for an unknown Venus OS version
# this of course may fail if a matching original file can not be found

# set allPackages to all packages this script should evalueate if no options are included
allPackages="SetupHelper GuiMods ExtTransferSwitch ShutdownMonitor VeCanSetup RpiDisplaySetup RpiGpioSetup"
## GeneratorConnector TankRepeater are obsolete and file sets should not be updated.

# set these as appropriate to your system
packageRoot="/Users/Kevin/GitHub"
stockFiles="$packageRoot/StockVenusOsFiles"

((totalErrors=0))
((totalWarnings=0))

outputtingProgress=false

function logMessage ()
{
	if $outputtingProgress ; then
		clearProgress
	fi
    echo "$*"
    if [[ "$*" == *"ERROR "* ]]; then
        ((totalErrors++))
        ((packageErrors++))
    elif [[ "$*" == *"WARNING"* ]]; then
        ((totalWarnings++))
    fi
}

function outputProgress ()
{
	echo -en "$1"
	outputtingProgress=true
}

function clearProgress ()
{
	echo -ne "\r\033[2K"
	outputtingProgress=false
}

function versionStringToNumber ()
{
    local local p4="" ; local p5="" ; local p6=""
    local major=""; local minor=""

	# first character should be 'v' so first awk parameter will be empty and is not prited into the read command
	#
	# version number formats: v2.40, v2.40~6, v2.40-large-7, v2.40~6-large-7
	# so we must adjust how we use paramters read from the version string
	# and parsed by awk
	# if no beta make sure release is greater than any beta (i.e., a beta portion of 999)
	 
    read major minor p4 p5 p6 <<< $(echo $1 | awk -v FS='[v.~-]' '{print $2, $3, $4, $5, $6}')
	((versionNumber = major * 1000000 + minor * 1000))
	if [ -z $p4 ] || [ $p4 = "large" ]; then
        ((versionNumber += 999))
	else
		((versionNumber += p4))
    fi
	if [ ! -z $p4 ] && [ $p4 = "large" ]; then
		((versionNumber += p5 * 1000))
		large=$p5
	elif [ ! -z $p6 ]; then
		((versionNumber += p6 * 1000))
	fi
}

#### script code begins here

packageList=""
doAllPackages=false
for param in $* ; do
	if [ "$param" == "all" ]; then
		doAllPackages=true
	else
		packageList+=" "$1
	fi
	shift
done
if $doAllPackages ; then
    packageList=$allPackages
elif [ -z "$packageList" ]; then
	logMessage "ERROR no packages specified - use 'all' for all packages"
	exit
fi

# make the version list from the directories in stock files
# version lists are sorted so the most recent version is first
tempList=""
versionList=($(ls -d "$stockFiles"/v* 2> /dev/null))
for entry in ${versionList[@]} ; do
    version=$(basename $entry)
    versionFile="$stockFiles/$version/opt/victronenergy/version"
    realVersion=$(cat "$versionFile" | head -n 1)

    if [ $version != $realVersion ]; then
        directoryName=$(basename $stockFiles)/$version
        logMessage "ERROR $directoryName name does not mactch Venus $realVersion - can't continue"
        exit
    fi
	versionStringToNumber $version
	tempList+=("$version:$versionNumber")
done
versionList=( $(echo ${tempList[@]} | tr ' ' '\n' | sort -t ':' -r -n -k 2 | uniq ) )

for package in $packageList; do
	packageErrors=0
	packageDirectory="$packageRoot/$package"
	backupDirectory="$packageRoot/$package.backup"
    if [ ! -d "$packageDirectory" ] || [ ! -f "$packageDirectory/version" ]; then
        logMessage "$packageDirectory - not a package directory"
        continue
    fi
	packageFiles="$packageDirectory/FileSets"
    if [ ! -d "$packageFiles" ]; then
        logMessage "$package: no file sets"
        continue
    fi
    if [ ! -f "$packageFiles/fileList" ]; then
        logMessage "$package: no version-dependent files"
        continue
    fi
    fileList=$(cat "$packageFiles/fileList")
    if [ -f "$fileList" ]; then
        logMessage "ERROR $package: empty file list"
        continue
    fi

	# backup package directory in case we choose to abandon changes later
	logMessage "backing up $package"
	rm -rf "$backupDirectory"
	cp -pR "$packageDirectory" "$backupDirectory"

	# add a package's existing file sets to stock versions
	existingFileSets=($(ls -d "$packageFiles"/v* 2> /dev/null))
	tempList=(${versionList[@]})
	for entry in ${existingFileSets[@]} ; do
		version=$(basename $entry)
		versionStringToNumber $version
			tempList+=($version:$versionNumber)
	done
	allVersions=( $(echo ${tempList[@]} | tr ' ' '\n' | sort -t ':' -r -n -k 2 | uniq ) )
	
	# clean up flag files from a previous run
	# process versions in stock files
	for fileSet in ${existingFileSets[@]} ; do
		rm -f "$fileSet/INCOMPATIBLE_VERSION"
		rm -f "$fileSet/UNUSED_FILE_SET"
		rm -f "$fileSet/NEW_FILE_SET"
		rm -f "$fileSet/INCOMPLETE"
		rm -f "$fileSet/COMPLETE"
		rm -f "$fileSet/LINKS_ONLY"
		rm -f "$fileSet/"*.NO_ORIG
		rm -f "$fileSet/"*.NO_REPLACEMENT
		rm -f "$fileSet/"*.NO_REPLACEMENT_LINK
		rm -f "$fileSet/"*.CHECK_REPLACEMENT
	done
	# process versions in stock files
    for entry1 in ${versionList[@]} ; do
		IFS=':' read version1 version1number <<< "$entry1"
        fileSet1="$packageFiles/$version1"

        # check to see if package is compatible with this Venus version
        if [ -f "$packageDirectory/obsoleteVersion" ]; then
            versionStringToNumber $(cat "$packageDirectory/obsoleteVersion")
            obsoleteVersion=$versionNumber
		else
			obsoleteVersion=999999999
		fi
        if [ -f "$packageDirectory/firstCompatibleVersion" ]; then
            versionStringToNumber $(cat "$packageDirectory/firstCompatibleVersion")
            firstVersion=$versionNumber
		else
			firstVersion=0
		fi
        
		if (( $version1number >= $obsoleteVersion )) || (( $version1number < $firstVersion )); then
			if [ -d "$fileSet1" ]; then 
				logMessage "WARNING $package: not compatible with Venus $version1 - file set should be removed"
				touch "$fileSet1/INCOMPATIBLE_VERSION"
			fi
			continue
		fi
		clearProgress
		outputProgress "$package $version1 "

        if [ ! -d "$fileSet1" ]; then
            mkdir "$fileSet1"
            touch "$fileSet1/NEW_FILE_SET"
        fi

        for file in $fileList ; do
            baseName=$(basename "$file")
			replacementFile1="$fileSet1/$baseName"
			origFile1="$fileSet1/$baseName.orig"

			# remove any existing symlinks for original files - they aren't needed
			if [ -L "$origFile1" ]; then
				rm -f "$origFile1"
			fi

			# skip if this file matched one in a prevous scan
			if [ -f "$origFile1.MATCHES_PREVIOUS" ]; then
				continue
			fi
			outputProgress "."

            # use alternate original if present
            if [ -f "$packageFiles/$baseName.ALT_ORIG" ]; then
                useAltOrig=true
                altOrigFile=$(cat "$packageFiles/$baseName.ALT_ORIG")
            else
                useAltOrig=false
                altOrigFile=""
            fi
            # select appropirate original file
            if $useAltOrig ; then
				stockFile1="$stockFiles/$version1$altOrigFile"
			else
				stockFile1="$stockFiles/$version1$file"
            fi
            # no original file - flag that then check for an existing replacemement
            if [ ! -f "$stockFile1" ]; then
                logMessage "ERROR $package: $version1 $baseName - no stock file"
                # flag the fact that no stock file exists
                touch "$fileSet1/$baseName.NO_ORIG"
                rm -f "$origFile1"
                if [ -e $fileSet1/$baseName ]; then
                    rm -f "$fileSet1/$baseName.USE_ORIGINAL"
                else
                    logMessage "ERROR $package: $version1 $baseName - no stock file so no replacement file"
                    touch "$fileSet1/$baseName.NO_REPLACEMENT"
                    touch "$fileSet1/INCOMPLETE"
                fi
                continue
            fi

            # look for a match in another version - use all versions,
            #	including file sets just in package directory
			for entry2 in ${allVersions[@]} ; do
				IFS=':' read version2 version2number <<< "$entry2"
				if (( "$version2number" == "$version1number" )); then
					continue
				fi
                fileSet2="$packageFiles/$version2"
                replacementFile2="$fileSet2/$baseName"
				origFile2="$fileSet2/$baseName.orig"

				stockFilesMatch=false
				# stock files exist
				if [ -d "$stockFiles/$version2" ]; then
				   # select appropriate original file
					if $useAltOrig ; then
						stockFile2="$stockFiles/$version2$altOrigFile"
					else
						stockFile2="$stockFiles/$version2$file"
					fi
					if [ ! -e "$stockFile2" ]; then
						logMessage "ERROR $package: $baseName $version2 stock file missing - can't continue"
						exit
					fi
					cmp -s "$stockFile2" "$stockFile1" > /dev/null
					# stock files match - relocate files from fs 2 to fs 1
					if [ $? -eq 0 ]; then
						stockFilesMatch=true
						if [ ! -d "$fileSet2" ]; then
							mkdir "$fileSet2"
							touch "$fileSet2/NEW_FILE_SET"
						fi
						touch "$origFile2.MATCHES_PREVIOUS"
						if [ -f "$origFile2" ] && [ ! -L "$origFile2" ]; then
							logMessage "$package: moving $baseName $version2 to $version1 (stock)"
							mv -f "$origFile2" "$origFile1"
							if [ -f "$replacementFile2" ] && [ ! -L "$replacementFile2" ]; then
								mv -f "$replacementFile2" "$replacementFile1"
							fi
							if [ -f "$replacementFile2.USE_ORIGINAL" ]; then
								mv -f "$replacementFile2.USE_ORIGINAL" "$replacementFile1.USE_ORIGINAL"
							fi
						fi
					fi
				# no stock files but existing file set
				elif [ -d $fileSet2 ] ; then
					if [ -f "$origFile2" ] && [ ! -L "$origFile2" ]; then
						cmp -s "$origFile2" "$stockFile1"
						if [ $? -eq 0 ] ;then
							stockFilesMatch=true
							logMessage "$package: moving $baseName $version2 to $version1 (existing FS)"
							mv -f "$origFile2" "$origFile1"
							if [ -f "$replacementFile2" ] && [ ! -L "$replacementFile2" ]; then
								mv -f "$replacementFile2" "$replacementFile1"
							elif [ -f "$replacementFile2.USE_ORIGINAL" ]; then
								mv -f "$replacementFile2.USE_ORIGINAL" "$replacementFile1.USE_ORIGINAL"
							else
								logMessage "ERROR $package: can't move $baseName $version2 to $version1"
								touch "$replacementFile1.NO_REPLACEMENT"
								touch "$fileSet1/INCOMPLETE"
							fi
						fi
					fi
				fi
				# created links for fs 2
				if $stockFilesMatch ; then
					if [ -f "$replacementFile1" ] && [ ! -L "$replacementFile1" ]; then
						ln -sf "../$version1/$baseName" "$replacementFile2"
						rm -f "$replacementFile2.USE_ORIGINAL"
					elif [ -f "$replacementFile1.USE_ORIGINAL" ]; then
						touch "$replacementFile2.USE_ORIGINAL"
					# no replacement in fs 1
					else
						# remove any inappropriate sym link
						if [ -L "$replacementFile2" ]; then
							rm -f "$replacementFile2"
						fi
						logMessage "ERROR $package: no replacement link for $baseName $version2"
						touch "$replacementFile2.NO_REPLACEMENT_LINK"
						touch "$fileSet2/INCOMPLETE"
					fi
				fi
            done # for version2

			# only change file set if orig does not exist or it does NOT match the file from StockFiles
			if [ -f "$origFile1" ]; then
				cmp -s "$stockFile1" "$origFile1"
				if [ $? -eq 0 ]; then
					newOrig=false
				else
					newOrig=true
				fi
			else
				newOrig=true
			fi
			if $newOrig ; then
				cp "$stockFile1" "$origFile1"
			fi
			# if replacement already exists, don't touch it but flag a manual check should be made
			if [ -f "$replacementFile1" ] && [ ! -L "$replacementFile1" ]; then
				if $newOrig ; then
					logMessage "WARNING $package: $version1 $baseName new original found but existing replacement - CHECK REPLACEMENT"
					touch "$replacementFile1.CHECK_REPLACEMENT"
					rm -f "$replacementFile1.USE_ORIGINAL"
				fi
			# no replacement - flag the error
			elif [ ! -f "$replacementFile1.USE_ORIGINAL" ] || [ -L "$replacementFile1.USE_ORIGINAL" ]; then
				logMessage "ERROR $package: $version1 $baseName - no replacement file"
				touch "$replacementFile1.NO_REPLACEMENT"
				touch "$fileSet1/INCOMPLETE"
				if [ -L "$replacementFile1" ]; then
					rm "$replacementFile1"
				fi
			fi
        done # for file
    done  # for entry1

    # cleanup file sets
    versionList1=($(ls -d "$packageFiles"/v* 2> /dev/null))
    for fileSet in ${versionList1[@]} ; do
        version=$(basename $fileSet)
		clearProgress
		outputProgress "$package $version cleanup"
        fileSet="$packageFiles/$version"
        if [ ! -d "$fileSet" ]; then
			continue
		fi

		# if all replacement files are in place, mark the file set COMPLETE
		#	so _checkFileSets can skip all checks
		# COMPLETE tells _checkFileSets to skip all checks and accept the file set as is
		if [ -f "$fileSet/INCOMPLETE" ]; then
			rm -f "$fileSet/COMPLETE"
		else
			touch "$fileSet/COMPLETE"
		fi


		# check for existing files
		# if none are found, file set can be deleted
		replacementFilesExist=false
		replacmentSymLinksExist=false
		for file in $fileList ; do
			baseName=$(basename "$file")
			replacementFile="$fileSet/$baseName"
			if [ -L "$replacementFile" ]; then
				replacmentSymLinksExist=true
			elif [ -f "$replacementFile" ]; then
				replacementFilesExist=true
			elif [ -f "$replacementFile.NO_REPLACEMENT" ]; then
				replacementFilesExist=true
			elif [ -f "$replacementFile.NO_REPLACEMENT_LINK" ]; then
				replacementFilesExist=true
			elif [ -f "$replacementFile.CHECK_REPLACEMENT" ]; then
				replacementFilesExist=true
			elif [ -f "$replacementFile.USE_ORIGINAL" ]; then
				replacementFilesExist=true
			fi
			if [ -f "$replacement.orig" ]; then
				replacementFilesExist=true
			fi
		done

		# file set is in stock files
		if [ -d "$stockFiles/$version" ]; then
			if ! $replacementFilesExist && $replacmentSymLinksExist ; then
				touch "$fileSet/LINKS_ONLY"
			fi
		# not in stock files list
		else
			if $replacementFilesExist ; then
				logMessage "WARNING $package: $version no longer used but not empty - manual remove is OK"
				touch "$fileSet/UNUSED_FILE_SET"
			# no files (empty file set)
			else
				# log removal of a previous file set if not created with this run
				# if it was created with this run, delete it silently
				if [ ! -f "$fileSet/NEW_FILE_SET" ]; then
					logMessage "$package: removing empty file set $version"
				fi
				rm -rf $fileSet
			fi
		fi

		# remove temporary flag files
		rm -f "$fileSet/"*MATCHES_PREVIOUS
		rm -f "$fileSet/NEW_FILE_SET"
    done # for fileSet (cleanup)
	if (( $packageErrors > 0 )) ; then
		logMessage "$package: $packageErrors ERRORS"
	else
		logMessage "$package: no errors"
	fi

	response=''
	while true; do
		/bin/echo -n "keep the changes (y / n)?: "
		read response
		case $response in
			[yY]*)
				rm -rf "$backupDirectory"
				break
				;;
			[nN]*)
				logMessage "restoring $package"
				rm -rf "$packageDirectory"
				mv "$backupDirectory" "$packageDirectory"
				break
				;;
			*)
		esac
	done
done # for package

# review all file sets and report any that only contain sym links across all packages
# it would be possile to remove those verions from stock files without loosing any data
# this check is only done if updating all file sets and there are no errors
if $doAllPackages && [ "$totalErrors" == 0 ]; then
	logMessage "checking for versions that contain no actual replacement files"
    for entry in ${versionList[@]} ; do
		IFS=':' read version versionNumber <<< "$entry"
		linksOnly=true
		for package in $packageList; do
			fileSet="$packageRoot/$package/FileSets/$version"
			if [ ! -e "$fileSet/LINKS_ONLY" ]; then
				linksOnly=false
				break
			fi
		done
		if $linksOnly ; then
			logMessage "$version: only links in all packages"
		fi
	done
fi

if [ "$totalErrors" == 0 ]; then
    errorText="no errors  "
else
    errorText="$totalErrors ERRORS  "
fi
if [ "$totalWarnings" == 0 ]; then
    warningText="no warnings  "
else
    warningText="$totalWarnings WARNINGS  "
fi
logMessage "script complete $errorText $warningText"

# ask if changes sho
