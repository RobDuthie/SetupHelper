#!/bin/bash

# this script updates file sets for all packages in the list below
# it scans all Venus OS versions in the stockFiles directory
#
# This is a unix bash script and should be run on a host computer, not a GX device
# Windows will not run this script natively.
# However Windows 10 apparently supports bash:
# https://www.howtogeek.com/249966/how-to-install-and-use-the-linux-bash-shell-on-windows-10/
#
# packages to be evaulated may be specified on the command line
# use 'all' to process all packages in the allPackages list below
#
# only file sets for released versions will be created/updated
# the highest numbered beta version will be included if there is no newer released version
# if v2.2~4, v2.2~5 and v2.2 all exist, no file sets will be created for ~4 and ~5 
# if v2.2~4, v2.2~5 exist, no file sets will be created for ~4
#
# include betas on the command line if file sets for all beta versions should be created/updated
#
# stockFiles contains "master" file sets for all Venus files
# excerpts from Venus OS file systems must be stored on the host
# within a directory with name of the exact Venus OS version
# and within the stockFiles directory defined below.
#
# 1) missing file set directories are created
# 2) if any files in fileList don't exist (eg, a new file was added to file list),
#   the original file in /opt and /etc is copied to the version directory
# 3) if the original file does not exist, the file is so marked with .NO_ORIG
# 4) version-dependent files without an original can use an "alternate original"
#   specified in FileSets. This permits version checks for these files too
# 5) file sets that contain no files are removed, minimizing the number of file sets
#   to check for a matching original
#
# when a stock file set does not exist, this script will check files from existing file sets
#	to create other versions
#
# existing file sets not in the releasedVersionList should be empty after the script runs
#	and will be deleted automatically

# set allPackages to all packages this script should evalueate if no options are included
allPackages="SetupHelper GuiMods ExtTransferSwitch ShutdownMonitor VeCanSetup RpiDisplaySetup RpiGpioSetup"
## GeneratorConnector TankRepeater are obsolete and file sets should not be updated.

# set these as appropriate to your system
packageRoot="/Users/Kevin/Documents/GitHub"
stockFiles="$packageRoot/StockVenusOsFiles"

((totalErrors=0))
((totalWarnings=0))

logMessage ()
{
    echo "$*"
    if [[ "$*" == *"ERROR"* ]]; then
        ((totalErrors++))
    elif [[ "$*" == *"WARNING"* ]]; then
        ((totalWarnings++))
    fi
}

function versionStringToNumber ()
{
    local local p4="" ; local p5="" ; local p6=""
    local major=""; local minor=""

	# first character should be 'v' so first awk parameter will be empty and is not prited into the read command
	#
	# version number formats: v2.40, v2.40~6, v2.40-large-7, v2.40~6-large-7
	# so we must adjust how we use paramters read from the version string
	# and parsed by awk
	# if no beta make sure release is greater than any beta (i.e., a beta portion of 999)
	 
    read major minor p4 p5 p6 <<< $(echo $1 | awk -v FS='[v.~-]' '{print $2, $3, $4, $5, $6}')
	((versionNumber = major * 1000000 + minor * 1000))
	if [ -z $p4 ] || [ $p4 = "large" ]; then
        ((versionNumber += 999))
	else
		((versionNumber += p4))
    fi
	if [ ! -z $p4 ] && [ $p4 = "large" ]; then
		((versionNumber += p5 * 1000))
		large=$p5
	elif [ ! -z $p6 ]; then
		((versionNumber += p6 * 1000))
	fi
}

#### script code begins here

includeBetas=false

packageList=""
doAllPackages=false
for param in $* ; do
	if [ "$param" == "betas" ]; then
		includeBetas=true
	elif [ "$param" == "all" ]; then
		doAllPackages=true
	else
		packageList+=" "$1
	fi
	shift
done
if $doAllPackages ; then
    packageList=$allPackages
elif [ -z "$packageList" ]; then
	logMessage "ERROR no packages specified - use 'all' for all packages"
	exit
fi

# make the version list from the directories in stock files
# version lists are sorted so the most recent version is first
# if includeBetas is false, remove all betas except the highest version
tempList=""
versionList=($(ls -d "$stockFiles"/v* 2> /dev/null))
for entry in ${versionList[@]} ; do
    version=$(basename $entry)
    versionFile="$stockFiles/$version/opt/victronenergy/version"
    realVersion=$(cat "$versionFile" | head -n 1)

    if [ $version != $realVersion ]; then
        directoryName=$(basename $stockFiles)/$version
        logMessage "ERROR $directoryName name does not mactch Venus $realVersion - can't continue"
        exit
    fi
	versionStringToNumber $version
	tempList+=("$version:$versionNumber")
done
versionList=( $(echo ${tempList[@]} | tr ' ' '\n' | sort -t ':' -r -n -k 2 | uniq ) )
firstEntry=true
fileSetList=""
for entry in ${versionList[@]} ; do
	version=$(echo $entry | awk -F ':' '{print $1}')
	if $firstEntry || $includeBetas || [[ $version != *~* ]]; then
		fileSetList+=($entry)
	fi
	firstEntry=false
done

for package in $packageList; do
    if [ ! -d "$packageRoot/$package" ] || [ ! -f "$packageRoot/$package/version" ]; then
        logMessage "$packageRoot/$package - not a package directory"
        continue
    fi
	packageFiles="$packageRoot/$package/FileSets"
    if [ ! -d "$packageFiles" ]; then
        logMessage "$package: no file sets"
        continue
    fi
    if [ ! -f "$packageFiles/fileList" ]; then
        logMessage "$package: no version-dependent files"
        continue
    fi
    fileList=$(cat "$packageFiles/fileList")
    if [ -f "$fileList" ]; then
        logMessage "ERROR $package: empty file list"
        continue
    fi
	logMessage "$package: checking file sets"

	# add a package's existing file sets to fileSetList
	# all directories in allVersions will be scanned looking for content to populate each file set
	existingFileSets=($(ls -d "$packageFiles"/v* 2> /dev/null))
	tempList=(${fileSetList[@]})
	for entry in ${existingFileSets[@]} ; do
		version=$(basename $entry)
		versionStringToNumber $version
			tempList+=($version:$versionNumber)
	done
	allVersions=( $(echo ${tempList[@]} | tr ' ' '\n' | sort -t ':' -r -n -k 2 | uniq ) )
	
	# clean up flag files from a previous run
	for fileSet in ${existingFileSets[@]} ; do
		rm -f "$fileSet/INCOMPATIBLE_VERSION"
		rm -f "$fileSet/RETAIN_THIS_VERSION"
		rm -f "$fileSet/UNUSED_FILE_SET"
		rm -f "$fileSet/NEW_FILE_SET"
		rm -f "$fileSet/"*.NO_ORIG
		rm -f "$fileSet/"*.NO_REPLACEMENT
		rm -f "$fileSet/"*.CHECK_REPLACEMENT
	done

    for entry1 in ${fileSetList[@]} ; do
		IFS=':' read version1 version1number <<< "$entry1"
		fileSetInUse=false
        fileSet1="$packageFiles/$version1"

        # check to see if package is compatible with this Venus version
        if [ -f "$packageRoot/$package/obsoleteVersion" ]; then
            versionStringToNumber $(cat "$packageRoot/$package/obsoleteVersion")
            obsoleteVersion=$versionNumber
		else
			obsoleteVersion=999999999
		fi
        if [ -f "$packageRoot/$package/firstCompatibleVersion" ]; then
            versionStringToNumber $(cat "$packageRoot/$package/firstCompatibleVersion")
            firstVersion=$versionNumber
		else
			firstVersion=0
		fi
        
		if (( $version1number >= $obsoleteVersion )) || (( $version1number < $firstVersion )); then
			if [ -d "$fileSet1" ]; then 
				logMessage "WARNING $package: not compatible with Venus $version1 - file set should be removed"
				touch "$fileSet1/INCOMPATIBLE_VERSION"
			fi
			continue
		fi

        if [ ! -d "$fileSet1" ]; then
            mkdir "$fileSet1"
            touch "$fileSet1/NEW_FILE_SET"
        fi

        for file in $fileList ; do
            baseName=$(basename "$file")
			replacementFile1="$fileSet1/$baseName"
			origFile1="$fileSet1/$baseName.orig"

			# skip if this file matched one in a prevous scan
			if [ -f "$origFile1.MATCHES_PREVIOUS" ]; then
				continue
			fi

            # use alternate original if present
            if [ -f "$packageFiles/$baseName.ALT_ORIG" ]; then
                useAltOrig=true
                altOrigFile=$(cat "$packageFiles/$baseName.ALT_ORIG")
            else
                useAltOrig=false
                altOrigFile=""
            fi
            # select appropirate original file
            if $useAltOrig ; then
				stockFile1="$stockFiles/$version1$altOrigFile"
			else
				stockFile1="$stockFiles/$version1$file"
            fi
            # no original file - flag that then check for an existing replacemement
            if [ ! -f "$stockFile1" ]; then
                logMessage "ERROR $package: $version1 $baseName - no original file"
                # flag the fact that no stock file exists
                touch "$fileSet1/$baseName.NO_ORIG"
                fileSetInUse=true
                rm -f "$origFile1"
                if [ -e $fileSet1/$baseName ]; then
                    rm -f "$fileSet1/$baseName.USE_ORIGINAL"
                else
                    logMessage "ERROR $package: $version1 $baseName - no original so no replacement file"
                    touch "$fileSet1/$baseName.NO_REPLACEMENT"
                fi
                continue
            fi
            
            # look for a match in another version - use all versions, not just the release list
			for entry2 in ${allVersions[@]} ; do
				IFS=':' read version2 version2number <<< "$entry2"
				if (( "$version2number" == "$version1number" )); then
					continue
				fi
                fileSet2="$packageFiles/$version2"
                replacementFile2="$fileSet2/$baseName"
				origFile2="$fileSet2/$baseName.orig"

				if [ -L "$replacementFile2" ] ; then
					logMessage "$package: removing symlink $baseName $version2 - no longer used"
					rm "$replacementFile2"
				fi
				if [ -L "$origFile2" ] ; then
					logMessage "$package: removing symlink $baseName.orig $version2 - no longer used"
					rm "$origFile2"
				fi

				# stock files exist
				if [ -d "$stockFiles/$version2" ]; then
				   # select appropriate original file
					if $useAltOrig ; then
						stockFile2="$stockFiles/$version2$altOrigFile"
					else
						stockFile2="$stockFiles/$version2$file"
					fi
					if [ ! -e "$stockFile2" ]; then
						logMessage "ERROR $package: $baseName $version2 stock file missing - can't continue"
						exit
					fi
					cmp -s "$stockFile2" "$stockFile1" > /dev/null
					# stock files match - relocate files from fs 2 to fs 1
					if [ $? -eq 0 ]; then
						if [ ! -d "$fileSet2" ]; then
							mkdir "$fileSet2"
							touch "$fileSet2/NEW_FILE_SET"
						fi
						touch "$origFile2.MATCHES_PREVIOUS"
						if [ -f "$origFile2" ]; then
							logMessage "$package: moving $baseName $version2 to $version1 (stock)"
							mv -f "$origFile2" "$origFile1"
							fileSetInUse=true
							if [ -f "$replacementFile2" ]; then
								mv -f "$replacementFile2" "$replacementFile1"
							fi
							if [ -f "$replacementFile2.USE_ORIGINAL" ]; then
								mv -f "$replacementFile2.USE_ORIGINAL" "$replacementFile1.USE_ORIGINAL"
							fi
						fi

						if [ -f "$replacementFile1" ] && [ -f "$replacementFile2" ]; then
							cmp -s "$replacementFile1" "$replacementFile2"
							# clean up file set 2 - file set for version 1 has necessary files
							if [ $? -eq 0 ]; then
								rm -f "$replacementFile2"
								rm -f "$origFile2"
								rm -f "$fileSet2/$baseName.USE_ORIGINAL"
							else
								logMessage "ERROR $package: $baseName replacement differs $version2 $version1 but origials are identical"
							fi
						fi
					fi
				# no stock files but existing file set
				elif [ -d $fileSet2 ] ; then
					if [ -f "$origFile2" ]; then
						cmp -s "$origFile2" "$stockFile1"
						if [ $? -eq 0 ] ;then
							logMessage "$package: moving $baseName $version2 to $version1 (existing FS)"
							mv -f "$origFile2" "$origFile1"
							fileSetInUse=true
							if [ -f "$replacementFile2" ]; then
								mv -f "$replacementFile2" "$replacementFile1"
							elif [ -f "$replacementFile2.USE_ORIGINAL" ]; then
								mv -f "$replacementFile2.USE_ORIGINAL" "$replacementFile1.USE_ORIGINAL"
							else
								logMessage "ERROR $package: can't move $baseName $version2 to $version1"
								touch "$replacementFile1.NO_REPLACEMENT"
							fi
						fi
					fi
				fi
            done # for version2

			# only change file set if orig does not exist or it does NOT match the file from StockFiles
			if [ -f "$origFile1" ]; then
				cmp -s "$stockFile1" "$origFile1"
				if [ $? -eq 0 ]; then
					newOrig=false
				else
					newOrig=true
				fi
			else
				newOrig=true
			fi
			if $newOrig ; then
				cp "$stockFile1" "$origFile1"
				fileSetInUse=true
			fi
			# if replacement already exists, don't touch it but flag a manual check should be made
			if [ -f "$replacementFile1" ]; then
				fileSetInUse=true
				if $newOrig ; then
					logMessage "WARNING $package: $baseName new original found but existing replacement - CHECK REPLACEMENT"
					touch "$replacementFile1.CHECK_REPLACEMENT"
					rm -f "$replacementFile1.USE_ORIGINAL"
				fi
			elif [ -e "$replacementFile1.USE_ORIGINAL" ]; then
				fileSetInUse=true
			else
				logMessage "ERROR $package: $version1 $baseName - no replacement file"
				touch "$replacementFile1.NO_REPLACEMENT"
			fi
        done # for file

		if $fileSetInUse ; then
			touch "$fileSet1/RETAIN_THIS_VERSION"
		fi
    done  # for v1

    # check for file sets that no longer exist in original files
    packageList=($(ls -d "$packageFiles"/v* 2> /dev/null))
    for v1 in ${packageList[@]} ; do
        version=$(basename $v1)
        fileSet="$packageFiles/$version"
        if [ -d "$fileSet" ]; then
            # check for real files (not sym-links)
            # if none are found, file set can be deleted
            fileSetEmpty=true
            for file in $fileList ; do
                baseName=$(basename "$file")
                replacementFile="$fileSet/$baseName"
                if [ -f "$replacementFile" ] && [ ! -L "$replacementFile" ]; then
                    fileSetEmpty=false
                    break;
                fi
                stockFile=$replacement.orig
                if [ -f "$stockFile" ] && [ ! -L "$stockFile" ]; then
                    fileSetEmpty=false
                    break;
                fi
                if [ -f "$replacementFile.NO_REPLACEMENT" ]; then
                     fileSetEmpty=false
                    break;
                fi
                if [ -f "$replacementFile.CHECK_REPLACEMENT" ]; then
                     fileSetEmpty=false
                    break;
                fi
                if [ -f "$replacementFile.USE_ORIGINAL" ]; then
                     fileSetEmpty=false
                    break;
                fi
               
            done
            if $fileSetEmpty ; then
				# log removal of a previous file set
				if [ ! -f "$fileSet/NEW_FILE_SET" ]; then
					logMessage "$package: removing empty file set $version"
				fi
                rm -rf $fileSet
            # not in stockFiles
            elif [ ! -d "$stockFiles/$version" ]; then
                logMessage "WARNING $package: $version not in stock files - manual remove is OK"
				touch "$fileSet/UNUSED_FILE_SET"
			elif [ ! -f "$fileSet/RETAIN_THIS_VERSION" ]; then
                logMessage "WARNING $package: $version is not a released version - manual remove is OK"
				touch "$fileSet/UNUSED_FILE_SET"
            fi
			# remove temporary flag files
			rm -f "$fileSet/"*MATCHES_PREVIOUS
			rm -f "$fileSet/RETAIN_THIS_VERSION"
			rm -f "$fileSet/NEW_FILE_SET"
        fi
    done
done
if [ "$totalErrors" == 0 ]; then
    errorText="no errors  "
else
    errorText="$totalErrors ERRORS  "
fi
if [ "$totalWarnings" == 0 ]; then
    warningText="no warnings  "
else
    warningText="$totalWarnings WARNINGS  "
fi
echo "script complete $errorText $warningText"
