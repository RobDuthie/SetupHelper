#!/bin/bash

# this script updates file sets for all packages in the list below
# it scans all Venus OS versions in the originalFiles directory
#
# This is a unix bash script and should be run on a host computer, not a GX device
# Windows will not run this script natively.
# However Windows 10 apparently supports bash:
# https://www.howtogeek.com/249966/how-to-install-and-use-the-linux-bash-shell-on-windows-10/
#
# packages to be evaulated may be specified on the command line when calling this script
# without options, packages in the allPackages list will be evaluated
#
# originalFiles contains "master" file sets for all Venus files
# excerpts from Venus OS file systems must be stored on the host
# within a directory with name of the exact Venus OS version
# and withn the originalFiles directory defined below.
#
# 1) missing file set directories are created
# 2) if any files in fileList don't exist (eg, a new file was added to file list),
#   the original file in /opt and /etc is copied to the version directory
# 3) if the original file does not exist, the file set is so marked with .NO_ORIG
# 4) version-dependent files without an original can use an "alternate original"
#   specified in FileSets. This permits version checks for these files too
# 5) file sets that contain no files are removed, minimizing the number of file sets
#   to check for a matching original
#

# set allPackages to all packages this script should evalueate if no options are included
allPackages="SetupHelper GuiMods ExtTransferSwitch ShutdownMonitor VeCanSetup RpiDisplaySetup RpiGpioSetup"
### GeneratorConnector TankRepeater are currently obsolete and file sets should not be updated.

# set these as appropriate to your system
packageRoot="/Users/Kevin/Documents/GitHub"
originalFiles="$packageRoot/OriginalVenusOsFiles"

((totalErrors=0))
((totalWarnings=0))

logMessage ()
{
    echo "$*"
    if [[ "$*" == *"ERROR"* ]]; then
        ((totalErrors++))
    elif [[ "$*" == *"WARNING"* ]]; then
        ((totalWarnings++))
    fi
}

function versionStringToNumber ()
{
    local local p4="" ; local p5="" ; local p6=""
    local major=""; local minor=""

	# first character should be 'v' so first awk parameter will be empty and is not prited into the read command
	#
	# version number formats: v2.40, v2.40~6, v2.40-large-7, v2.40~6-large-7
	# so we must adjust how we use paramters read from the version string
	# and parsed by awk
	# if no beta make sure release is greater than any beta (i.e., a beta portion of 999)
	 
    read major minor p4 p5 p6 <<< $(echo $1 | awk -v FS='[v.~-]' '{print $2, $3, $4, $5, $6}')
	((versionNumber = major * 1000000 + minor * 1000))
	if [ -z $p4 ] || [ $p4 = "large" ]; then
        ((versionNumber += 999))
	else
		((versionNumber += p4))
    fi
	if [ ! -z $p4 ] && [ $p4 = "large" ]; then
		((versionNumber += p5 * 1000))
		large=$p5
	elif [ ! -z $p6 ]; then
		((versionNumber += p6 * 1000))
	fi
}


if [ -z $1 ]; then
    packageList=$allPackages
else
    packageList=$*
fi

# check to make sure the dictory name matches /opt/victronenergy/version
rm -f /tmp/foo
rawVersionList=($(ls -d "$originalFiles"/v*))
for ver in ${rawVersionList[@]} ; do
    version=$(basename $ver)
    versionFile="$originalFiles/$version/opt/victronenergy/version"
    realVersion=$(cat "$versionFile" | head -n 1)

    if [ $version != $realVersion ]; then
        directoryName=$(basename $originalFiles)/$version
        logMessage "ERROR $directoryName name does not mactch Venus $realVersion - can't continue"
		rm -f /tmp/foo
        exit
    fi
	versionStringToNumber $version
	echo "$version $versionNumber" >> /tmp/foo
done

# versionList is sorted in reverse version order
versionList=( $(sort -r -n -k 2 /tmp/foo | awk '{print $1}') )
rm -f /tmp/foo

for package in $packageList; do
    if [ ! -d "$packageRoot/$package" ] || [ ! -f "$packageRoot/$package/version" ]; then
        logMessage "$packageRoot/$package - not a package directory"
        continue
    fi
	packageFiles="$packageRoot/$package/FileSets"
    if [ ! -d "$packageFiles" ]; then
        logMessage "$package: no file sets"
        continue
    fi
    if [ ! -f "$packageFiles/fileList" ]; then
        logMessage "$package: no version-dependent files"
        continue
    fi
    fileList=$(cat "$packageFiles/fileList")
    if [ -f "$fileList" ]; then
        logMessage "ERROR $package: empty file list"
        continue
    fi
	logMessage "$package: checking file sets"

    for index1 in ${!versionList[@]} ; do
		version1=${versionList[$index1]}
        fileSet1="$packageFiles/$version1"

        # check to see if package is compatible with this Venus version
        if [ -f "$packageRoot/$package/obsoleteVersion" ]; then
            versionStringToNumber $(cat "$packageRoot/$package/obsoleteVersion")
            obsoleteVersion=$versionNumber
		else
			obsoleteVersion=999999999
		fi
        if [ -f "$packageRoot/$package/firstCompatibleVersion" ]; then
            versionStringToNumber $(cat "$packageRoot/$package/firstCompatibleVersion")
            firstVersion=$versionNumber
		else
			firstVersion=0
		fi
        
		versionStringToNumber $version1
		version1number=$versionNumber
		if (( $version1number < $obsoleteVersion )) && (( $version1number >= $firstVersion )); then
			if [ -d "$fileSet1" ]; then 
				rm -f "$fileSet1/INCOMPATIBLE_VERSION"
			fi
		else
			if [ -d "$fileSet1" ]; then 
				logMessage "WARNING $package not compatible with Venus $version1 - file set should be removed"
				touch "$fileSet1/INCOMPATIBLE_VERSION"
			fi
			continue
		fi

        if [ -d "$fileSet1" ]; then
            newFileSet=false
        else
            mkdir "$fileSet1"
            newFileSet=true
        fi

        for file in $fileList ; do
            baseName=$(basename "$file")
			replacementFile1="$fileSet1/$baseName"
			origFile1="$fileSet1/$baseName.orig"

			# skip if this version matches file in prevous file set
			if [ -f "$origFile1.MATCHES_PREVIOUS" ]; then
				continue
			fi

			# cleanup flags from previous run
			rm -f "$fileSet1/$baseName.NO_ORIG"
			rm -f "$fileSet1/$baseName.NO_REPLACEMENT"
			rm -f "$fileSet1/$baseName.CHECK_REPLACEMENT"
			
            # alternate original if present
            if [ -f "$packageFiles/$baseName.ALT_ORIG" ]; then
                useAltOrig=true
                altOrigFile=$(cat "$packageFiles/$baseName.ALT_ORIG")
            else
                useAltOrig=false
                altOrigFile=""
            fi
            # select appropirate original file
            if $useAltOrig ; then
				stockFile1="$originalFiles/$version1$altOrigFile"
			else
				stockFile1="$originalFiles/$version1$file"
            fi
            # no original file - flag that then check for an existing replacemement
            if [ ! -f "$stockFile1" ]; then
                logMessage "WARNING $package $version1 $baseName - no original file"
                # flag the fact that no stock file exists
                touch "$fileSet1/$baseName.NO_ORIG"
                rm -f "$origFile1"
                if [ -e $fileSet1/$baseName ]; then
                    rm -f "$fileSet1/$baseName.USE_ORIGINAL"
                else
                    logMessage "ERROR $package $version1 $baseName - no original so no replacement file"
                    touch "$fileSet1/$baseName.NO_REPLACEMENT"
                fi
                continue
            fi
            
            # look for a match in another version
			for version2 in ${versionList[@]:(($index1 + 1))} ; do
                fileSet2="$packageFiles/$version2"
                replacementFile2="$fileSet2/$baseName"
				origFile2="$fileSet2/$baseName.orig"

				if [ -L "$replacementFile2" ] ; then
					logMessage "WARNING removing symlink $baseName $version2 - no longer used"
					rm "$replacementFile2"
				fi
				if [ -L "$origFile2" ] ; then
					logMessage "WARNING removing symlink $baseName.orig $version2 - no longer used"
					rm "$origFile2"
				fi

               # select appropriate original file
				if $useAltOrig ; then
					stockFile2="$originalFiles/$version2$altOrigFile"
				else
					stockFile2="$originalFiles/$version2$file"
				fi
                if [ ! -e "$stockFile2" ]; then
					logMessage "ERROR $baseName $version2 stock file missing - can't continue"
					exit
				fi
                
				cmp -s "$stockFile2" "$stockFile1" > /dev/null
				if [ $? -eq 0 ]; then
					if [ ! -d "$fileSet2" ]; then
						mkdir "$fileSet2"
					fi
					touch "$origFile2.MATCHES_PREVIOUS"
					stockMatch=true
				else
					stockMatch=false
				fi
                
				if $stockMatch ; then
					# move lower versioned matching files to higher numbered version
					if [ -f "$origFile2" ]; then
						logMessage "moving $baseName $version2 to $version1"
						rm -f "$origFile1"
						mv "$origFile2" "$origFile1"
						if [ -f "$replacementFile2" ]; then
							rm -f "$replacementFile1"
							mv "$replacementFile2" "$replacementFile1"
						fi
						if [ -f "$fileSet2/$baseName.USE_ORIGINAL" ]; then
							rm -f "$fileSet2/$baseName.USE_ORIGINAL"
							touch "$fileSet1/$baseName.USE_ORIGINAL"
						fi
					fi

					if [ -f "$replacementFile1" ]; then
						if [ -f "$replacementFile2" ]; then
							cmp -s "$replacementFile1" "$replacementFile2"
							# clean up file set 2 - file set for version 1 has necessary files
							if [ $? -eq 0 ]; then
								rm -f "$replacementFile2"
								rm -f "$origFile2"
								rm -f "$fileSet2/$baseName.USE_ORIGINAL"
							else
								logMessage "ERROR $baseName replacement differs $version2 $version1 but origials are identical"
							fi
						fi
					fi
                fi
            done # for version2

			# only change file set if orig does not exist or it does NOT match the file from OriginalFiles
			if [ -f "$origFile1" ]; then
				cmp -s "$stockFile1" "$origFile1"
				if [ $? -eq 0 ]; then
					newOrig=false
				else
					newOrig=true
				fi
			else
				newOrig=true
			fi
			if $newOrig ; then
				logMessage "$package $version1 $baseName fetching original file"
				cp "$stockFile1" "$origFile1"
			fi
			# if replacement already exists, don't touch it but flag a manual check should be made
			if [ -f "$fileSet1/$baseName" ]; then
				if $newOrig ; then
					logMessage "WARNING new original found but existing replacement - CHECK REPLACEMENT"
					touch "$fileSet1/$baseName.CHECK_REPLACEMENT"
					rm -f "$fileSet1/$baseName.USE_ORIGINAL"
				fi
			elif [ ! -e "$fileSet1/$baseName.USE_ORIGINAL" ]; then
				logMessage "ERROR $package $version1 $baseName - no replacement file"
				touch "$fileSet1/$baseName.NO_REPLACEMENT"
			fi
        done # for file

        # remove empty file sets
        $(ls -1qA $fileSet1 | grep  -vq "^\.")
        if [ $? -ne 0 ]; then
            # report removal of existing file sets, but not those just created
            if ! $newFileSet ; then
                logMessage "$package $version1 file set empty -- removing"
            fi
            rm -rf $fileSet1
        # report creation of a new file set (created above)
        elif $newFileSet ; then
            logMessage "$package $version1 created new file set"
        fi
    done  # for v1

    # check for file sets that no longer exist in original files
    packageList=($(ls -d "$packageFiles"/v*))
    for v1 in ${packageList[@]} ; do
        version=$(basename $v1)
        fileSet="$packageFiles/$version"
        if [ -d "$fileSet" ]; then
			rm -f "$fileSet/"*MATCHES_PREVIOUS

            # check for real files (not sym-links)
            # if none are found, file set can be deleted
            fileSetEmpty=true
            for file in $fileList ; do
                baseName=$(basename "$file")
                replacementFile="$fileSet/$baseName"
                if [ -f "$replacementFile" ] && [ ! -L "$replacementFile" ]; then
                    fileSetEmpty=false
                    break;
                fi
                stockFile=$replacement.orig
                if [ -f "$stockFile" ] && [ ! -L "$stockFile" ]; then
                    fileSetEmpty=false
                    break;
                fi
                if [ -f "$replacementFile.NO_REPLACEMENT" ]; then
                     fileSetEmpty=false
                    break;
                fi
                if [ -f "$replacementFile.CHECK_REPLACEMENT" ]; then
                     fileSetEmpty=false
                    break;
                fi
                if [ -f "$replacementFile.USE_ORIGINAL" ]; then
                     fileSetEmpty=false
                    break;
                fi
               
            done
            if $fileSetEmpty ; then
                logMessage "$package $version - deleting empty file set"
                rm -rf $fileSet
            # not in originalFiles
            elif [ ! -d "$originalFiles/$version" ]; then
                logMessage "WARNING $package $version not in OriginalFiles - manual remove is OK"
            fi
        fi
    done
done
if [ "$totalErrors" == 0 ]; then
    errorText="no errors  "
else
    errorText="$totalErrors ERRORS  "
fi
if [ "$totalWarnings" == 0 ]; then
    warningText="no warnings  "
else
    warningText="$totalWarnings WARNINGS  "
fi
echo "script complete $errorText $warningText"
